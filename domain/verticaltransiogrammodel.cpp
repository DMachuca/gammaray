#include "verticaltransiogrammodel.h"
#include "domain/application.h"

#include <cassert>
#include <QTextStream>
#include <QFile>
#include "util.h"

VerticalTransiogramModel::VerticalTransiogramModel(QString path,
                                                   QString associatedCategoryDefinitionName ) :
        File( path ),
        m_associatedCategoryDefinitionName( associatedCategoryDefinitionName )
{

}

QIcon VerticalTransiogramModel::getIcon()
{
    return QIcon(":icons32/transiogram32");
}

QString VerticalTransiogramModel::getTypeName()
{
    return "VERTICALTRANSIOGRAMMODEL";
}

void VerticalTransiogramModel::save(QTextStream *txt_stream)
{
    (*txt_stream) << this->getFileType() << ":" << this->getFileName() << '\n';
    //also saves the metadata file.
    this->updateMetaDataFile();
}

bool VerticalTransiogramModel::canHaveMetaData()
{
    return true;
}

QString VerticalTransiogramModel::getFileType()
{
    return getTypeName();
}

void VerticalTransiogramModel::updateMetaDataFile()
{
    QFile file( this->getMetaDataFilePath() );
    file.open( QFile::WriteOnly | QFile::Text );
    QTextStream out(&file);
    out << APP_NAME << " metadata file.  This file is generated automatically.  Do not edit this file.\n";
    out << "version=" << APP_VERSION << '\n';
    if( ! m_associatedCategoryDefinitionName.isEmpty() )
        out << "ASSOCIATED_CATEGORY_DEFINITION:" << m_associatedCategoryDefinitionName << '\n';
    file.close();
}

void VerticalTransiogramModel::writeToFS()
{
    //create a new file for output
    QFile outputFile( QString( this->getPath() ).append(".new") );
    outputFile.open( QFile::WriteOnly | QFile::Text );

    QTextStream out(&outputFile);

    //write the column headers
    for( const QString& headerFacies : m_columnHeadersFaciesNames )
        out << '\t' << headerFacies ;

    //write the lines ( headers and transiogram parameters)
    std::vector< std::vector< VTransiogramParameters > >::const_iterator itTransiogramsLines = m_verticalTransiogramsMatrix.cbegin();
    for( const QString& headerFacies : m_lineHeadersFaciesNames ){
        out << headerFacies ;
        std::vector< VTransiogramParameters >::const_iterator itTransiograms = (*itTransiogramsLines).cbegin();
        for( ; itTransiograms != (*itTransiogramsLines).end() ; ++itTransiograms)
            out << '\t' << static_cast<int>   (std::get<0>(*itTransiograms)) << ','  //structure type: spheric, exponential, gaussian, etc...
                        << static_cast<double>(std::get<1>(*itTransiograms)) << ','  //transiogram range:
                        << static_cast<double>(std::get<2>(*itTransiograms));        //transiogram sill:
        ++itTransiogramsLines;
    }

    // close output file
    outputFile.close();

    // deletes the current file
    QFile currentFile(this->getPath());
    currentFile.remove();
    // renames the .new file, effectively replacing the current file.
    outputFile.rename(this->getPath());
}

void VerticalTransiogramModel::readFromFS()
{
    //open the input file for reading
    QFile inputFile( getPath() );
    if ( inputFile.open(QIODevice::ReadOnly | QFile::Text ) ) {
        clearLoadedContents();
        QTextStream in(&inputFile);
        int lineNumber = 0;
        while ( !in.atEnd() ){
            ++lineNumber;
            // get the text file line
            QString line = in.readLine();
            // tokenize the line
            std::vector<std::string> tokens = Util::tokenizeWithDoubleQuotes( line.toStdString(), false );
            // the column headers
            if( lineNumber == 1 ){
                for( const std::string& token : tokens )
                    m_columnHeadersFaciesNames.push_back( QString( token.c_str() ) );
            //the lines, each with a fascies name as their headers
            } else {
                int columnNumber = 0;
                std::vector< VTransiogramParameters > lineOfTransiogramParameters;
                for( const std::string& token : tokens ){
                    ++columnNumber;
                    if( columnNumber == 1)
                        m_lineHeadersFaciesNames.push_back( QString( token.c_str() ) );
                    else{
                        QString verticalTransiogramParameters = QString( token.c_str() );
                        bool ok;


                        lineOfProbValues.push_back( probValue );
                    }
                }
                if( lineOfProbValues.size() != m_columnHeadersFaciesNames.size() ){
                    Application::instance()->logWarn("VerticalTransiogramModel::readFromFS(): number of vertical transiograms values differs from the "
                                                     "number of facies names in the header @ line " + QString::number(lineNumber) + ".");
                }
                m_transitionCounts.push_back( lineOfProbValues );
            }
        }
        inputFile.close();
    } else {
        Application::instance()->logError("VerticalTransiogramModel::readFromFS(): file " + getPath() + " not found or is not accessible.");
    }
}
