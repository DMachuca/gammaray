#include "verticaltransiogrammodel.h"
#include "domain/application.h"

#include <cassert>
#include <QTextStream>
#include <QFile>
#include "util.h"

VerticalTransiogramModel::VerticalTransiogramModel(QString path,
                                                   QString associatedCategoryDefinitionName ) :
        File( path ),
        m_associatedCategoryDefinitionName( associatedCategoryDefinitionName )
{

}

QIcon VerticalTransiogramModel::getIcon()
{
    return QIcon(":icons32/transiogram32");
}

QString VerticalTransiogramModel::getTypeName()
{
    return "VERTICALTRANSIOGRAMMODEL";
}

void VerticalTransiogramModel::save(QTextStream *txt_stream)
{
    (*txt_stream) << this->getFileType() << ":" << this->getFileName() << '\n';
    //also saves the metadata file.
    this->updateMetaDataFile();
}

bool VerticalTransiogramModel::canHaveMetaData()
{
    return true;
}

QString VerticalTransiogramModel::getFileType()
{
    return getTypeName();
}

void VerticalTransiogramModel::updateMetaDataFile()
{
    QFile file( this->getMetaDataFilePath() );
    file.open( QFile::WriteOnly | QFile::Text );
    QTextStream out(&file);
    out << APP_NAME << " metadata file.  This file is generated automatically.  Do not edit this file.\n";
    out << "version=" << APP_VERSION << '\n';
    if( ! m_associatedCategoryDefinitionName.isEmpty() )
        out << "ASSOCIATED_CATEGORY_DEFINITION:" << m_associatedCategoryDefinitionName << '\n';
    file.close();
}

void VerticalTransiogramModel::writeToFS()
{
    //create a new file for output
    QFile outputFile( QString( this->getPath() ).append(".new") );
    outputFile.open( QFile::WriteOnly | QFile::Text );

    QTextStream out(&outputFile);

    //write the column headers
    for( const QString& headerFacies : m_columnHeadersFaciesNames )
        out << '\t' << headerFacies ;

    //write the lines ( headers and transiogram parameters)
    std::vector< std::vector< VTransiogramParameters > >::const_iterator itTransiogramsLines = m_verticalTransiogramsMatrix.cbegin();
    for( const QString& headerFacies : m_lineHeadersFaciesNames ){
        out << headerFacies ;
        std::vector< VTransiogramParameters >::const_iterator itTransiograms = (*itTransiogramsLines).cbegin();
        for( ; itTransiograms != (*itTransiogramsLines).end() ; ++itTransiograms)
            out << '\t' << static_cast<int>   (std::get<0>(*itTransiograms)) << ','  //structure type: spheric, exponential, gaussian, etc...
                        << static_cast<double>(std::get<1>(*itTransiograms)) << ','  //transiogram range:
                        << static_cast<double>(std::get<2>(*itTransiograms));        //transiogram sill:
        ++itTransiogramsLines;
    }

    // close output file
    outputFile.close();

    // deletes the current file
    QFile currentFile(this->getPath());
    currentFile.remove();
    // renames the .new file, effectively replacing the current file.
    outputFile.rename(this->getPath());
}

void VerticalTransiogramModel::readFromFS()
{
    //open the input file for reading
    QFile inputFile( getPath() );
    if ( inputFile.open(QIODevice::ReadOnly | QFile::Text ) ) {
        clearLoadedContents();
        QTextStream in(&inputFile);
        int lineNumber = 0;
        while ( !in.atEnd() ){
            ++lineNumber;
            // get the text file line
            QString line = in.readLine();
            // tokenize the line
            std::vector<std::string> tokens = Util::tokenizeWithDoubleQuotes( line.toStdString(), false );
            // the column headers
            if( lineNumber == 1 ){
                for( const std::string& token : tokens )
                    m_columnHeadersFaciesNames.push_back( QString( token.c_str() ) );
            //the lines, each with a fascies name as their headers
            } else {
                int columnNumber = 0;
                std::vector< VTransiogramParameters > lineOfTransiogramParameters;
                for( const std::string& token : tokens ){
                    ++columnNumber;
                    if( columnNumber == 1)
                        m_lineHeadersFaciesNames.push_back( QString( token.c_str() ) );
                    else{
                        // get the string "<type>,<range>,<sill>"
                        QString verticalTransiogramParameters = QString( token.c_str() );
                        // get the tokens as separate itens
                        QStringList verticalTransiogramParametersTokens = verticalTransiogramParameters.split(',');
                        //convert the tokens to numeric values
                        bool ok = false;
                        VTransiogramStructureType iStructureType;
                        VTransiogramRange fRange;
                        VTransiogramSill fSill;
                        for( int i = 0; i < verticalTransiogramParametersTokens.size(); ++i )
                            switch ( i ) {
                            case 0: iStructureType = static_cast<VTransiogramStructureType>( verticalTransiogramParametersTokens[i].toInt( &ok ) ); break;
                            case 1: fRange = verticalTransiogramParametersTokens[i].toDouble( &ok ); break;
                            case 2: fSill = verticalTransiogramParametersTokens[i].toDouble( &ok ); break;
                            }
                        if( ! ok )
                            Application::instance()->logError("VerticalTransiogramModel::readFromFS(): conversion to number failed @ line " + QString::number(lineNumber) + ""
                                                              " of file " + this->getPath() + ".");
                        //add the newly built tuple of variograph parameyters to the line vector.
                        lineOfTransiogramParameters.push_back( { iStructureType, fRange, fSill } );
                    }
                }
                if( lineOfTransiogramParameters.size() != m_columnHeadersFaciesNames.size() ){
                    Application::instance()->logWarn("VerticalTransiogramModel::readFromFS(): number of vertical transiograms differs from the "
                                                     "number of facies names in the header @ line " + QString::number(lineNumber) + ".");
                }
                //add the line of transiograms to the outer vector, forming a matrix of vertical transiogram models.
                m_verticalTransiogramsMatrix.push_back( lineOfTransiogramParameters );
            }
        }
        inputFile.close();
    } else {
        Application::instance()->logError("VerticalTransiogramModel::readFromFS(): file " + getPath() + " not found or is not accessible.");
    }
}

void VerticalTransiogramModel::clearLoadedContents()
{
    m_columnHeadersFaciesNames.clear();
    m_lineHeadersFaciesNames.clear();
    m_verticalTransiogramsMatrix.clear();
}

bool VerticalTransiogramModel::isDataFile()
{
    return false;
}

bool VerticalTransiogramModel::isDistribution()
{
    return false;
}

void VerticalTransiogramModel::deleteFromFS()
{
    File::deleteFromFS(); //delete the file itself.
    //also deletes the metadata file
    QFile file( this->getMetaDataFilePath() );
    file.remove(); //TODO: throw exception if remove() returns false (fails).  Also see QIODevice::errorString() to see error message.
}
